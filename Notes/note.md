Well, there’s two types of binaries on any system: statically linked and dynamically linked. Statically linked binaries are self-contained, containing all of the code necessary for them to run within the single file, and do not depend on any external libraries. Dynamically linked binaries (which are the default when you run gcc and most other compilers) do not include a lot of functions, but rely on system libraries to provide a portion of the functionality. For example, when your binary uses printf to print some data, the actual implementation of printf is part of the system C library. Typically, on current GNU/Linux systems, this is provided by libc.so.6, which is the name of the current GNU Libc library.

In order to locate these functions, your program needs to know the address of printf to call it. While this could be written into the raw binary at compile time, there’s some problems with that strategy:

1. Each time the library changes, the addresses of the functions within the library change, when libc is upgraded, you’d need to rebuild every binary on your system.
2. Modern systems using ASLR load libraries at different locations on each program invocation. Hardcoding addresses would render this impossible.

Consequently, a strategy was developed to allow looking up all of these addresses when the program was run and providing a mechanism to call these functions from libraries. This is known as relocation, and the hard work of doing this at runtime is performed by the linker, aka ld-linux.so. (Note that every dynamically linked program will be linked against the linker, this is actually set in a special ELF section called .interp.) The linker is actually run before any code from your program or libc, but this is completely abstracted from the user by the Linux kernel.

#### Relocations

Looking at an ELF file, you will discover that it has a number of sections, and it turns out that relocations require several of these sections. I’ll start by defining the sections, then discuss how they’re used in practice.

1. .got
   This is the GOT, or Global Offset Table. This is the actual table of offsets as filled in by the linker for external symbols.
2. .plt
   This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.)
3. .got.plt
   This is the GOT for the PLT. It contains the target addresses (after they have been looked up) or an address back in the .plt to trigger the lookup. Classically, this data was part of the .got section.
4. .plt.got
   It seems like they wanted every combination of PLT and GOT! This just seems to contain code to jump to the first entry of the .got.

#### Stack Alignment

A small issue you may get when pwning on 64-bit systems is that your exploit works perfectly locally but fails remotely - or even fails when you try to use the provided LIBC version rather than your local one. This arises due to something called stack alignment.
Essentially the x86-64 ABI (application binary interface) guarantees 16-byte alignment on a call instruction. LIBC takes advantage of this and uses SSE data transfer instructions to optimise execution; system in particular utilises instructions such as movaps.
That means that if the stack is not 16-byte aligned - that is, RSP is not a multiple of 16 - the ROP chain will fail on system.
The fix is simple - in your ROP chain, before the call to system, place a singular ret gadget

```asm
ret = elf.address + 0x2439
[...]
rop.raw(POP_RDI)
rop.raw(0x4)        # first parameter
rop.raw(ret)        # align the stack
rop.raw(system)
```

This works because it will cause RSP to be popped an additional time, pushing it forward by 8 bytes and aligning it.

#### Stack Canaries

Stack Canaries are very simple - at the beginning of the function, a random value is placed on the stack. Before the program executes ret, the current value of that variable is compared to the initial: if they are the same, no buffer overflow has occurred.
If they are not, the attacker attempted to overflow to control the return pointer and the program crashes, often with a **_ stack smashing detected _** error message.

**_ On Linux, stack canaries end in 00. This is so that they null-terminate any strings in case you make a mistake when using print functions, but it also makes them much easier to spot. _**

#### PIE(Position Independent Executable)

**_PIE stands for Position Independent Executable, which means that every time you run the file it gets loaded into a different memory address. This means you cannot hardcode values such as function addresses and gadget locations without finding out where they are. _**

PIE executables are based around relative rather than absolute addresses, meaning that while the locations in memory are fairly random the offsets between different parts of the binary remain constant. For example, if you know that the function main is located 0x128 bytes in memory after the base address of the binary, and you somehow find the location of main, you can simply subtract 0x128 from this to get the base address and from the addresses of everything else.

#### ASLR(Address Space Layout Randomisation)

**_ ASLR stands for Address Space Layout Randomisation and can, in most cases, be thought of as libc's equivalent of PIE - every time you run a binary, libc (and other libraries) get loaded into a different memory address. _**

While it's tempting to think of ASLR as libc PIE, there is a key difference.
ASLR is a kernel protection while PIE is a binary protection. The main difference is that PIE can be compiled into the binary while the presence of ASLR is completely dependant on the environment running the binary. If I sent you a binary compiled with ASLR disabled while I did it, it wouldn't make any difference at all if you had ASLR enabled.

#### RELRO(Relocation Read-Only)

RELRO is a protection to stop any GOT overwrites from taking place, and it does so very effectively. There are two types of RELRO, which are both easy to understand.

##### Partial RELRO

Partial RELRO simply moves the GOT above the program's variables, meaning you can't overflow into the GOT. This, of course, does not prevent format string overwrites.

##### Full RELRO

Full RELRO makes the GOT completely read-only, so even format string exploits cannot overwrite it. This is not the default in binaries due to the fact that it can make it take much longer to load as it need to resolve all the function addresses at once.

**_ Stack grows downward. _**
Byte = 8 bits
Word = 16 bits
Double Word(dword) = 32 bits
Quad Word(qword) = 64 bits

When gets() function prompts us for data, it writes upward in stack, that is suppose our function has a variable, it will be stored for example at location ebp-0x4 and suppose we have gets() function at ebp-0x40, it will write the data in location for example at ebp-0x39
that is stack grows downward but gets() function writes in upward direction
This is how we can overwrite into the EIP if gets() function is present
So if we want to overwrite a variable at ebp-0x4 and gets function is at ebp-0x40 then we need to write ([(ebp-0x40) - (ebp-0x4)] + 1)bytes, assuming that variable is 4 bytes, even if we overwrite 1 byte of it, we can change its value

Call inst is basically pushing into the stack the address of next inst and jumping to whatever is the name of function after call.
Example : call general
push the next address as return pointer onto the stack then jmp to general() fucntion . Push operation decrements our stack pointer(ESP) since stack grows downwards
At the end of general() function we have a ret assembly instruction
ret = pop ecx(for example) then jmp ecx
pop increments ESP and places whatever ESP points to into the ecx reg.
jmp will move EIP to whatever is present in ecx

Stack image: Example case, we are calling a function named general()

1. Address of next inst after 'call general()' inst. gets pushed onto the stack so the program knows what address to return to when general() ends

2. Since we have pushed element onto the stack, RSP will decrement and point to return address and now we enter general function

3. Function has a prologue that defines its stack frame. Prologue contains instruction push rbp(old base pointer) --> mov rbp,rsp

4. This first pushes rbp(old base pointer) onto the stack and so now RSP will decrement and point to rbp(old base pointer) then placing the value of rsp into the rbp using inst. 'mov rbp,rsp'. This is how we define base pointer of actual stack frame and now the rbp is new base pointer

5. We refrence memory address relative to stacks base pointer

6. Suppose next inst is 'sub rsp,0x20'(for user input) so we move to that location and since before this, rsp == rbp, that lcation is called rbp-0x20. Now the RSP moves to this location since this inst. decrements RSP. Now user input will be stored at this location and assuming its 64 bit architechture, user input will be 8 bytes long

7. Prologue of function contains leave inst = mov rsp,rbp --> pop rbp, this puts RSP back to the bottom of stack frame, then we pop the value of rbp which increments RSP and above RSP current location is the return pointer

8. Now rbp is back to pointing to where it was before calling general() function and RSP is pointing at return address of general() function

9. So during execution flow hijacking, we input the buffer with more than allocated size to reach the return address and hijack the program control flow as user input grows upwards this allows us to reach the saved return address because writing into memory happens from lower towards higher address

10. In this example, to reach EIP we will require 0x20(32 in decimal)bytes + 0x8(8 in decimal)bytes, a total of 40 bytes to reach the return address and hjack the control flow of program
